"""
Vulnerability Time-Decay Scorer
================================
Applies time-based decay penalties to vulnerabilities for FICO-style scoring.

Implements a time-sensitive scoring model where vulnerabilities accumulate
additional penalties based on how long they remain unpatched, with severity-
appropriate decay rates.

Author: MCP Security Team
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from enum import Enum

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    UNKNOWN = "unknown"    # No CVSS score


@dataclass
class VulnerabilityScore:
    """Comprehensive vulnerability scoring result with time decay."""
    repository: str
    fico_score: int  # 300-850
    base_deduction: int
    age_penalty: int
    total_deduction: int
    vulnerabilities_by_age: Dict[str, List[int]]  # Age buckets with counts
    oldest_critical_days: Optional[int]
    oldest_high_days: Optional[int]
    mean_vulnerability_age: float
    total_vulnerabilities: int
    severity_counts: Dict[str, int]
    kev_count: int
    exploitable_count: int
    scan_date: str
    metadata: Dict = field(default_factory=dict)

    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'repository': self.repository,
            'fico_score': self.fico_score,
            'base_deduction': self.base_deduction,
            'age_penalty': self.age_penalty,
            'total_deduction': self.total_deduction,
            'vulnerabilities_by_age': self.vulnerabilities_by_age,
            'oldest_critical_days': self.oldest_critical_days,
            'oldest_high_days': self.oldest_high_days,
            'mean_vulnerability_age': self.mean_vulnerability_age,
            'total_vulnerabilities': self.total_vulnerabilities,
            'severity_counts': self.severity_counts,
            'kev_count': self.kev_count,
            'exploitable_count': self.exploitable_count,
            'scan_date': self.scan_date,
            'metadata': self.metadata
        }


class VulnerabilityTimeScorer:
    """
    Time-decay scoring for vulnerabilities with FICO output.

    Implements a sophisticated scoring model where:
    - Base penalties apply immediately upon discovery
    - Daily decay penalties accumulate over time
    - Severity determines decay rate
    - Special rules for KEV and ancient vulnerabilities
    """

    # Base deductions by severity (Day 0)
    BASE_DEDUCTIONS = {
        VulnerabilitySeverity.CRITICAL: -120,
        VulnerabilitySeverity.HIGH: -80,
        VulnerabilitySeverity.MEDIUM: -40,
        VulnerabilitySeverity.LOW: -15,
        VulnerabilitySeverity.UNKNOWN: -25
    }

    # Daily decay rates (points lost per day)
    DAILY_DECAY_RATES = {
        VulnerabilitySeverity.CRITICAL: -2.0,   # Aggressive decay
        VulnerabilitySeverity.HIGH: -1.0,
        VulnerabilitySeverity.MEDIUM: -0.5,
        VulnerabilitySeverity.LOW: -0.1,
        VulnerabilitySeverity.UNKNOWN: -0.3
    }

    # Maximum age penalties (cap at 90 days)
    MAX_AGE_PENALTY = {
        VulnerabilitySeverity.CRITICAL: -180,
        VulnerabilitySeverity.HIGH: -90,
        VulnerabilitySeverity.MEDIUM: -45,
        VulnerabilitySeverity.LOW: -9,
        VulnerabilitySeverity.UNKNOWN: -27
    }

    # Special penalties
    ANCIENT_VULNERABILITY_PENALTY = -50  # For vulns > 365 days
    KEV_MULTIPLIER = 2.0  # Double penalty for Known Exploited Vulnerabilities

    # Score caps
    CRITICAL_AGE_CAP_DAYS = 30  # Critical vuln > 30 days caps score at 579
    SCORE_CAP_WITH_OLD_CRITICAL = 579  # Poor rating

    def __init__(self,
                 base_score: int = 850,
                 min_score: int = 300):
        """
        Initialize vulnerability time scorer.

        Args:
            base_score: Starting FICO score (default 850)
            min_score: Minimum possible score (default 300)
        """
        self.base_score = base_score
        self.min_score = min_score

    def calculate_score(self, scan_result: 'OSVScanResult', repository: str = "unknown") -> VulnerabilityScore:
        """
        Calculate FICO score with time-decay penalties.

        Args:
            scan_result: OSV scan result with vulnerabilities
            repository: Repository name/path

        Returns:
            VulnerabilityScore with comprehensive scoring details
        """
        if not scan_result.success:
            # Return neutral score if scan failed
            return self._create_error_score(repository, scan_result.error_message)

        vulnerabilities = scan_result.vulnerabilities

        # Initialize tracking variables
        total_base_deduction = 0
        total_age_penalty = 0
        vulnerabilities_by_age = self._initialize_age_buckets()
        oldest_critical_days = None
        oldest_high_days = None
        kev_count = 0
        exploitable_count = 0

        # Process each vulnerability
        for vuln in vulnerabilities:
            # Get base deduction
            severity = self._get_severity(vuln.cvss_score)
            base_deduction = self.BASE_DEDUCTIONS.get(severity, -25)

            # Apply KEV multiplier if applicable
            if vuln.is_kev:
                base_deduction *= self.KEV_MULTIPLIER
                kev_count += 1

            total_base_deduction += base_deduction

            # Calculate age penalty
            age_penalty = self._calculate_age_penalty(severity, vuln.age_days)
            total_age_penalty += age_penalty

            # Track age buckets
            age_bucket = self._get_age_bucket(vuln.age_days)
            vulnerabilities_by_age[age_bucket].append(vuln.age_days)

            # Track oldest critical/high
            if severity == VulnerabilitySeverity.CRITICAL:
                if oldest_critical_days is None or vuln.age_days > oldest_critical_days:
                    oldest_critical_days = vuln.age_days
            elif severity == VulnerabilitySeverity.HIGH:
                if oldest_high_days is None or vuln.age_days > oldest_high_days:
                    oldest_high_days = vuln.age_days

            # Track exploitable
            if vuln.exploit_available:
                exploitable_count += 1

        # Calculate mean age
        all_ages = []
        for ages in vulnerabilities_by_age.values():
            all_ages.extend(ages)
        mean_age = sum(all_ages) / len(all_ages) if all_ages else 0

        # Calculate final score
        total_deduction = total_base_deduction + total_age_penalty
        fico_score = self.base_score + total_deduction

        # Apply floor
        fico_score = max(self.min_score, fico_score)

        # Apply cap if old critical vulnerability exists
        if oldest_critical_days and oldest_critical_days > self.CRITICAL_AGE_CAP_DAYS:
            fico_score = min(fico_score, self.SCORE_CAP_WITH_OLD_CRITICAL)

        # No bonus for zero vulnerabilities (per requirement)

        return VulnerabilityScore(
            repository=repository,
            fico_score=int(fico_score),
            base_deduction=int(total_base_deduction),
            age_penalty=int(total_age_penalty),
            total_deduction=int(total_deduction),
            vulnerabilities_by_age={k: len(v) for k, v in vulnerabilities_by_age.items()},
            oldest_critical_days=oldest_critical_days,
            oldest_high_days=oldest_high_days,
            mean_vulnerability_age=round(mean_age, 1),
            total_vulnerabilities=len(vulnerabilities),
            severity_counts=scan_result.severity_counts,
            kev_count=kev_count,
            exploitable_count=exploitable_count,
            scan_date=datetime.now().isoformat(),
            metadata={
                'scan_duration': scan_result.scan_duration,
                'total_packages': scan_result.total_packages,
                'vulnerable_packages': scan_result.vulnerable_packages
            }
        )

    def _get_severity(self, cvss_score: float) -> VulnerabilitySeverity:
        """Convert CVSS score to severity enum."""
        if cvss_score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif cvss_score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif cvss_score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif cvss_score > 0:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.UNKNOWN

    def _calculate_age_penalty(self, severity: VulnerabilitySeverity, age_days: int) -> float:
        """
        Calculate age-based penalty for a vulnerability.

        Args:
            severity: Vulnerability severity level
            age_days: Days since vulnerability was published

        Returns:
            Age penalty (negative value)
        """
        # Get daily decay rate
        daily_rate = self.DAILY_DECAY_RATES.get(severity, -0.3)

        # Calculate penalty (capped at 90 days)
        effective_days = min(age_days, 90)
        age_penalty = daily_rate * effective_days

        # Apply maximum penalty cap
        max_penalty = self.MAX_AGE_PENALTY.get(severity, -27)
        age_penalty = max(age_penalty, max_penalty)

        # Add ancient vulnerability penalty
        if age_days > 365:
            age_penalty += self.ANCIENT_VULNERABILITY_PENALTY

        return age_penalty

    def _initialize_age_buckets(self) -> Dict[str, List[int]]:
        """Initialize age bucket tracking."""
        return {
            "0-7 days": [],
            "8-30 days": [],
            "31-90 days": [],
            "91-180 days": [],
            "181-365 days": [],
            "365+ days": []
        }

    def _get_age_bucket(self, age_days: int) -> str:
        """Determine age bucket for vulnerability."""
        if age_days <= 7:
            return "0-7 days"
        elif age_days <= 30:
            return "8-30 days"
        elif age_days <= 90:
            return "31-90 days"
        elif age_days <= 180:
            return "91-180 days"
        elif age_days <= 365:
            return "181-365 days"
        else:
            return "365+ days"

    def _create_error_score(self, repository: str, error_message: str) -> VulnerabilityScore:
        """Create a neutral score when scanning fails."""
        return VulnerabilityScore(
            repository=repository,
            fico_score=670,  # Neutral "B" grade
            base_deduction=0,
            age_penalty=0,
            total_deduction=0,
            vulnerabilities_by_age=self._initialize_age_buckets(),
            oldest_critical_days=None,
            oldest_high_days=None,
            mean_vulnerability_age=0,
            total_vulnerabilities=0,
            severity_counts={'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'unknown': 0},
            kev_count=0,
            exploitable_count=0,
            scan_date=datetime.now().isoformat(),
            metadata={'error': error_message}
        )

    def get_remediation_priority(self, score: VulnerabilityScore) -> List[Dict]:
        """
        Generate prioritized remediation recommendations.

        Args:
            score: Vulnerability score result

        Returns:
            List of prioritized remediation tasks
        """
        priorities = []

        # Priority 1: KEV vulnerabilities
        if score.kev_count > 0:
            priorities.append({
                'priority': 1,
                'category': 'Known Exploited Vulnerabilities',
                'count': score.kev_count,
                'action': 'Patch immediately - active exploitation in the wild',
                'urgency': 'CRITICAL'
            })

        # Priority 2: Old critical vulnerabilities
        if score.oldest_critical_days and score.oldest_critical_days > 7:
            priorities.append({
                'priority': 2,
                'category': 'Aged Critical Vulnerabilities',
                'age_days': score.oldest_critical_days,
                'action': f'Patch critical vulnerabilities ({score.oldest_critical_days} days old)',
                'urgency': 'HIGH'
            })

        # Priority 3: Exploitable vulnerabilities
        non_kev_exploitable = score.exploitable_count - score.kev_count
        if non_kev_exploitable > 0:
            priorities.append({
                'priority': 3,
                'category': 'Exploitable Vulnerabilities',
                'count': non_kev_exploitable,
                'action': 'Patch vulnerabilities with known exploits',
                'urgency': 'HIGH'
            })

        # Priority 4: Ancient vulnerabilities
        ancient_count = len(score.vulnerabilities_by_age.get("365+ days", []))
        if ancient_count > 0:
            priorities.append({
                'priority': 4,
                'category': 'Ancient Vulnerabilities',
                'count': ancient_count,
                'action': 'Address vulnerabilities over 1 year old',
                'urgency': 'MEDIUM'
            })

        return priorities

    def calculate_remediation_impact(self,
                                    current_score: VulnerabilityScore,
                                    vulns_to_fix: List[Tuple[str, int]]) -> int:
        """
        Calculate score improvement from fixing specific vulnerabilities.

        Args:
            current_score: Current vulnerability score
            vulns_to_fix: List of (severity, age_days) tuples

        Returns:
            Projected new FICO score after remediation
        """
        # Calculate deductions that would be removed
        removed_deductions = 0

        for severity_str, age_days in vulns_to_fix:
            severity = VulnerabilitySeverity(severity_str)

            # Base deduction
            base = abs(self.BASE_DEDUCTIONS.get(severity, 25))

            # Age penalty
            age_penalty = abs(self._calculate_age_penalty(severity, age_days))

            removed_deductions += base + age_penalty

        # Calculate new score
        new_score = current_score.fico_score + removed_deductions

        # Apply ceiling
        new_score = min(new_score, self.base_score)

        return int(new_score)


def example_usage():
    """Example of using the time-decay scorer."""
    from osv_scanner import OSVScanResult, VulnerabilityFinding

    # Create sample scan result
    scan_result = OSVScanResult(
        sbom_path="example.sbom",
        scan_date=datetime.now(),
        vulnerabilities=[
            VulnerabilityFinding(
                package_name="lodash",
                current_version="4.17.11",
                fixed_version="4.17.21",
                cve_id="CVE-2021-23337",
                cvss_score=9.1,
                severity=VulnerabilitySeverity.CRITICAL,
                published_date=datetime.now() - timedelta(days=45),
                ecosystem="npm",
                description="Command injection vulnerability",
                age_days=45,
                is_kev=True,
                exploit_available=True
            ),
            VulnerabilityFinding(
                package_name="axios",
                current_version="0.21.0",
                fixed_version="0.21.2",
                cve_id="CVE-2021-3749",
                cvss_score=7.5,
                severity=VulnerabilitySeverity.HIGH,
                published_date=datetime.now() - timedelta(days=120),
                ecosystem="npm",
                description="Regular expression DoS",
                age_days=120,
                is_kev=False,
                exploit_available=False
            )
        ],
        total_packages=150,
        vulnerable_packages=2,
        scan_duration=5.2,
        severity_counts={'critical': 1, 'high': 1, 'medium': 0, 'low': 0, 'unknown': 0},
        success=True
    )

    # Score vulnerabilities
    scorer = VulnerabilityTimeScorer()
    score = scorer.calculate_score(scan_result, repository="example-repo")

    # Display results
    print(f"FICO Score: {score.fico_score}")
    print(f"Base Deduction: {score.base_deduction}")
    print(f"Age Penalty: {score.age_penalty}")
    print(f"Total Deduction: {score.total_deduction}")
    print(f"Oldest Critical: {score.oldest_critical_days} days")
    print(f"KEV Count: {score.kev_count}")

    # Get remediation priorities
    priorities = scorer.get_remediation_priority(score)
    print("\nRemediation Priorities:")
    for priority in priorities:
        print(f"  {priority['priority']}. {priority['category']}: {priority['action']}")


if __name__ == "__main__":
    example_usage()